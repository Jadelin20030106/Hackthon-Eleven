# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12iaUuNvivB8Q5bp3DhqJQ6REqYdroz8I
"""

import os
import json
import numpy as np
import pandas as pd
import streamlit as st

st.set_page_config(page_title="Next Purchase Recommendation Demo", layout="wide")


# ----------------------------
# Helpers
# ----------------------------
@st.cache_data(show_spinner=False)
def load_csv(path: str, **kwargs) -> pd.DataFrame:
    return pd.read_csv(path, **kwargs)

@st.cache_data(show_spinner=False)
def load_all_data(data_dir: str):
    clients = load_csv(os.path.join(data_dir, "clients.csv"))
    products = load_csv(os.path.join(data_dir, "products.csv"))
    transactions = load_csv(os.path.join(data_dir, "transactions.csv"))
    stocks = load_csv(os.path.join(data_dir, "stocks.csv"))

    # optional
    stores_path = os.path.join(data_dir, "stores.csv")
    stores = load_csv(stores_path) if os.path.exists(stores_path) else None

    # --- normalize ID types to str ---
    for df, col in [(clients, "ClientID"), (products, "ProductID")]:
        if col in df.columns:
            df[col] = df[col].astype(str)

    for df, cols in [(transactions, ["ClientID", "ProductID"]), (stocks, ["ProductID"])]:
        for c in cols:
            if c in df.columns:
                df[c] = df[c].astype(str)

    # normalize date
    if "SaleTransactionDate" in transactions.columns:
        transactions["SaleTransactionDate"] = pd.to_datetime(
            transactions["SaleTransactionDate"], errors="coerce"
        )

    return clients, products, transactions, stocks, stores

@st.cache_data(show_spinner=False)
def load_group_recommendations(data_dir: str) -> pd.DataFrame:
    """
    Prefer XGB file; fallback to LGB.
    Expected columns from your notebook export:
      ClientID, Recommended_ProductID, Rank (1-k), Score, Strategy, In_Stock_Flag, Product_Metadata, Universe, Category, Price...
    """
    xgb_path = os.path.join(data_dir, "recommendations_xgb_top30.csv")
    lgb_path = os.path.join(data_dir, "recommendations_lgb_top30.csv")

    if os.path.exists(xgb_path):
        rec = load_csv(xgb_path)
        rec["Model"] = "XGB"
    elif os.path.exists(lgb_path):
        rec = load_csv(lgb_path)
        rec["Model"] = "LGB"
    else:
        raise FileNotFoundError(
            "Missing recommendations file. Put recommendations_xgb_top30.csv or recommendations_lgb_top30.csv in the same folder as app.py."
        )

    # normalize column names robustly
    if "Recommended_ProductID" not in rec.columns and "ProductID" in rec.columns:
        rec = rec.rename(columns={"ProductID": "Recommended_ProductID"})

    if "Rank (1-k)" not in rec.columns and "Rank" in rec.columns:
        rec = rec.rename(columns={"Rank": "Rank (1-k)"})

    rec["ClientID"] = rec["ClientID"].astype(str)
    rec["Recommended_ProductID"] = rec["Recommended_ProductID"].astype(str)

    # ensure numeric
    if "Score" in rec.columns:
        rec["Score"] = pd.to_numeric(rec["Score"], errors="coerce").fillna(0.0)

    return rec

@st.cache_data(show_spinner=False)
def build_indexes(clients: pd.DataFrame, products: pd.DataFrame, transactions: pd.DataFrame, stocks: pd.DataFrame):
    # Client -> profile
    client_profile = clients.set_index("ClientID", drop=False) if "ClientID" in clients.columns else pd.DataFrame()

    # Product -> meta
    product_meta = products.set_index("ProductID", drop=False) if "ProductID" in products.columns else pd.DataFrame()

    # Transactions by user (for recent purchases)
    if "ClientID" in transactions.columns:
        tx_by_user = transactions.groupby("ClientID", sort=False)
    else:
        tx_by_user = None

    # Stock lookup: (country, product) -> qty
    # Your stocks.csv usually has columns: ProductID, StoreCountry, Quantity
    stock_country_col = "StoreCountry" if "StoreCountry" in stocks.columns else None
    stock_qty_col = "Quantity" if "Quantity" in stocks.columns else None

    stock_map = None
    if stock_country_col and stock_qty_col:
        tmp = stocks.copy()
        tmp["ProductID"] = tmp["ProductID"].astype(str)
        tmp[stock_country_col] = tmp[stock_country_col].astype(str)
        tmp[stock_qty_col] = pd.to_numeric(tmp[stock_qty_col], errors="coerce").fillna(0.0)
        tmp = tmp.groupby([stock_country_col, "ProductID"], as_index=False)[stock_qty_col].sum()
        stock_map = {(r[stock_country_col], r["ProductID"]): float(r[stock_qty_col]) for _, r in tmp.iterrows()}

    return client_profile, product_meta, tx_by_user, stock_map

@st.cache_data(show_spinner=False)
def build_country_popularity(transactions: pd.DataFrame, clients: pd.DataFrame, products: pd.DataFrame):
    """
    Cold-start fallback: country top products by GMV (SalesNetAmountEuro) if exists, else Quantity, else count.
    We use ClientCountry from clients as 'country of user'.
    """
    if "ClientID" not in transactions.columns or "ProductID" not in transactions.columns:
        return {}, []

    tx = transactions.copy()
    tx["ClientID"] = tx["ClientID"].astype(str)
    tx["ProductID"] = tx["ProductID"].astype(str)

    # attach user country
    if "ClientCountry" in clients.columns:
        cc = clients[["ClientID", "ClientCountry"]].copy()
        cc["ClientID"] = cc["ClientID"].astype(str)
        cc["ClientCountry"] = cc["ClientCountry"].astype(str)
        tx = tx.merge(cc, on="ClientID", how="left")
    else:
        tx["ClientCountry"] = "UNKNOWN"

    # popularity metric
    if "SalesNetAmountEuro" in tx.columns:
        pop = tx.groupby(["ClientCountry", "ProductID"], as_index=False)["SalesNetAmountEuro"].sum()
        pop = pop.rename(columns={"SalesNetAmountEuro": "popularity"})
    elif "Quantity" in tx.columns:
        pop = tx.groupby(["ClientCountry", "ProductID"], as_index=False)["Quantity"].sum()
        pop = pop.rename(columns={"Quantity": "popularity"})
    else:
        pop = tx.groupby(["ClientCountry", "ProductID"], as_index=False).size()
        pop = pop.rename(columns={"size": "popularity"})

    pop = pop.sort_values(["ClientCountry", "popularity"], ascending=[True, False])

    # dict: country -> list of productids
    country_top = {}
    for c, g in pop.groupby("ClientCountry", sort=False):
        country_top[str(c)] = g["ProductID"].astype(str).tolist()

    global_top = pop.groupby("ProductID", as_index=False)["popularity"].sum().sort_values("popularity", ascending=False)
    global_top = global_top["ProductID"].astype(str).tolist()

    return country_top, global_top

def get_stock_qty(stock_map, country: str, pid: str) -> float:
    if stock_map is None or country is None:
        return np.nan
    return stock_map.get((str(country), str(pid)), 0.0)

def enrich_recs(rec_df: pd.DataFrame, product_meta: pd.DataFrame, stock_map, country: str | None):
    out = rec_df.copy()
    # attach product meta
    if not product_meta.empty:
        out = out.merge(
            product_meta.reset_index(drop=True),
            left_on="Recommended_ProductID",
            right_on="ProductID",
            how="left",
            suffixes=("", "_meta"),
        )

    # stock qty
    if country is not None:
        out["StockQty"] = out["Recommended_ProductID"].apply(lambda x: get_stock_qty(stock_map, country, x))
    else:
        out["StockQty"] = np.nan

    return out


# ----------------------------
# UI
# ----------------------------
st.title("ðŸ›’ Next Purchase Recommendation Demo")
st.caption("Using your team's pipeline outputs (recall + rerank CSV) + stock filtering + cold-start dashboard")

DATA_DIR = os.path.dirname(os.path.abspath(__file__))

clients, products, transactions, stocks, stores = load_all_data(DATA_DIR)
recs_all = load_group_recommendations(DATA_DIR)

client_profile, product_meta, tx_by_user, stock_map = build_indexes(clients, products, transactions, stocks)
country_top, global_top = build_country_popularity(transactions, clients, products)

# quick stats
c1, c2, c3 = st.columns(3)
with c1:
    st.metric("Clients", f"{clients.shape[0]:,}")
with c2:
    st.metric("Products", f"{products.shape[0]:,}")
with c3:
    st.metric("Transactions", f"{transactions.shape[0]:,}")

st.success("Data loaded successfully!")

# Sidebar
with st.sidebar:
    st.header("Mode")
    mode = st.radio("Choose mode", ["Existing user", "New user (cold-start)"], index=0)

    st.header("Controls")
    topn = st.slider("Top-N recommendations", 5, 30, 10)
    cold_start_threshold = st.slider("Cold-start threshold (min purchases)", 1, 10, 3)
    filter_stock = st.checkbox("Only recommend in-stock in selected country", value=True)

    st.divider()

# ----------------------------
# Existing user mode
# ----------------------------
if mode == "Existing user":
    # user selection
    all_users = recs_all["ClientID"].unique().tolist()
    default_user = all_users[0] if all_users else None

    with st.sidebar:
        manual = st.text_input("Or type a ClientID (manual)", "")
        if manual.strip():
            user_id = manual.strip()
        else:
            user_id = st.selectbox("Select a user (ClientID)", all_users, index=0)

    # profile
    user_country = None
    if not client_profile.empty and user_id in client_profile.index and "ClientCountry" in client_profile.columns:
        user_country = str(client_profile.loc[user_id, "ClientCountry"])
    st.write(f"**Current user:** `{user_id}`" + (f"  |  **Country:** `{user_country}`" if user_country else ""))

    # purchases count
    purchase_cnt = 0
    recent_tx = pd.DataFrame()
    if tx_by_user is not None and user_id in tx_by_user.groups:
        user_tx = tx_by_user.get_group(user_id).copy()
        purchase_cnt = user_tx.shape[0]
        if "SaleTransactionDate" in user_tx.columns:
            user_tx = user_tx.sort_values("SaleTransactionDate", ascending=False)
        recent_tx = user_tx.head(10)

    st.write(f"**Transactions:** {purchase_cnt}")

    # Determine if cold-start for existing user
    is_cold = purchase_cnt < cold_start_threshold

    # --- Recommendations ---
    if not is_cold:
        user_recs = recs_all[recs_all["ClientID"] == user_id].copy()
        user_recs = user_recs.sort_values("Rank (1-k)", ascending=True).head(topn).copy()

        if filter_stock and user_country:
            # keep only stock>0 in user's country
            user_recs["StockQty"] = user_recs["Recommended_ProductID"].apply(lambda x: get_stock_qty(stock_map, user_country, x))
            user_recs = user_recs[user_recs["StockQty"] > 0].copy()
            user_recs = user_recs.head(topn)

        enriched = enrich_recs(user_recs, product_meta, stock_map, user_country if filter_stock else None)

        st.subheader("ðŸŽ¯ Recommendations (your model output)")
        show_cols = []
        for c in ["Rank (1-k)", "Recommended_ProductID", "Score", "Strategy", "In_Stock_Flag", "StockQty", "Universe", "Category", "Price"]:
            if c in enriched.columns:
                show_cols.append(c)
        if not show_cols:
            show_cols = enriched.columns.tolist()
        st.dataframe(enriched[show_cols], use_container_width=True)

    else:
        st.warning(f"This user has only {purchase_cnt} purchases (< cold-start threshold {cold_start_threshold}). Using cold-start popularity fallback.")
        base_list = country_top.get(user_country, []) if user_country else []
        if not base_list:
            base_list = global_top

        # apply stock filter if enabled and have country
        cand = []
        for pid in base_list:
            if filter_stock and user_country:
                if get_stock_qty(stock_map, user_country, pid) <= 0:
                    continue
            cand.append(pid)
            if len(cand) >= topn:
                break

        fallback = pd.DataFrame({"Recommended_ProductID": cand, "Score": np.arange(len(cand), 0, -1)})
        fallback["Rank (1-k)"] = np.arange(1, len(fallback) + 1)
        fallback["Strategy"] = "Cold-start (Popularity)"
        enriched = enrich_recs(fallback, product_meta, stock_map, user_country if filter_stock else None)

        st.subheader("ðŸŽ¯ Recommendations (cold-start fallback)")
        show_cols = [c for c in ["Rank (1-k)", "Recommended_ProductID", "Strategy", "StockQty", "Universe", "Category", "Price"] if c in enriched.columns]
        st.dataframe(enriched[show_cols], use_container_width=True)

    # --- Recent purchases ---
    st.subheader("ðŸ§¾ Recent purchases")
    if not recent_tx.empty:
        # attach product meta to recent purchases
        tx_show = recent_tx.copy()
        if "ProductID" in tx_show.columns and not product_meta.empty:
            tx_show = tx_show.merge(product_meta.reset_index(drop=True), on="ProductID", how="left", suffixes=("", "_meta"))

        tx_cols = [c for c in ["SaleTransactionDate", "ProductID", "Category", "Universe", "Quantity", "SalesNetAmountEuro"] if c in tx_show.columns]
        st.dataframe(tx_show[tx_cols].head(10), use_container_width=True)
    else:
        st.info("No transactions found for this user in transactions.csv.")

    # --- Dashboard charts ---
    st.subheader("ðŸ“Š Dashboard: Top categories (recommended)")
    try:
        # Use whatever was last displayed (recommendations)
        # Recompute an "enriched" rec list for chart safely:
        if not is_cold:
            chart_df = enrich_recs(
                recs_all[recs_all["ClientID"] == user_id].sort_values("Rank (1-k)").head(topn),
                product_meta, stock_map, user_country if filter_stock else None
            )
        else:
            chart_df = enriched

        if "Category" in chart_df.columns:
            cat = chart_df["Category"].fillna("Unknown").value_counts().head(10)
            st.bar_chart(cat)
        else:
            st.info("No Category column found in products.csv to plot.")
    except Exception as e:
        st.info(f"Chart skipped: {e}")

# ----------------------------
# New user (cold-start) mode
# ----------------------------
else:
    st.sidebar.subheader("New user profile")
    # country list
    countries = []
    if "ClientCountry" in clients.columns:
        countries = sorted([c for c in clients["ClientCountry"].dropna().astype(str).unique().tolist() if c and c != "nan"])
    if not countries:
        countries = ["UNKNOWN"]

    sel_country = st.sidebar.selectbox("Country", countries, index=0)
    gender_opts = ["Unknown"]
    if "ClientGender" in clients.columns:
        gender_opts = sorted([g for g in clients["ClientGender"].dropna().astype(str).unique().tolist() if g and g != "nan"])
        if "Unknown" not in gender_opts:
            gender_opts = ["Unknown"] + gender_opts
    sel_gender = st.sidebar.selectbox("Gender", gender_opts, index=0)

    age = st.sidebar.slider("Age", 10, 80, 30)

    st.write("**New user mode** â†’ we don't have history, so we use **country popularity** as a baseline, then apply **stock filter**.")
    st.write(f"Selected profile: **Country** `{sel_country}` | **Gender** `{sel_gender}` | **Age** `{age}`")

    base_list = country_top.get(sel_country, [])
    if not base_list:
        st.warning("No country popularity found for this country, fallback to global popularity.")
        base_list = global_top

    cand = []
    for pid in base_list:
        if filter_stock:
            if get_stock_qty(stock_map, sel_country, pid) <= 0:
                continue
        cand.append(pid)
        if len(cand) >= topn:
            break

    rec_new = pd.DataFrame({"Recommended_ProductID": cand})
    rec_new["Rank (1-k)"] = np.arange(1, len(rec_new) + 1)
    rec_new["Score"] = np.arange(len(rec_new), 0, -1)
    rec_new["Strategy"] = "New user (Popularity)"

    enriched = enrich_recs(rec_new, product_meta, stock_map, sel_country if filter_stock else None)

    st.subheader("ðŸŽ¯ Recommendations for new user")
    show_cols = [c for c in ["Rank (1-k)", "Recommended_ProductID", "StockQty", "Universe", "Category", "Price", "Strategy"] if c in enriched.columns]
    st.dataframe(enriched[show_cols], use_container_width=True)

    st.subheader("ðŸ“Š Dashboard: Top categories (recommended)")
    if "Category" in enriched.columns:
        cat = enriched["Category"].fillna("Unknown").value_counts().head(10)
        st.bar_chart(cat)
    else:
        st.info("No Category column found in products.csv to plot.")